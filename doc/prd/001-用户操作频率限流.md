# 用户操作频率限流 产品需求文档

**文档类型**：产品需求文档
**适用对象**：业务人员、产品、运营

| 版本号 | 更新时间 | 备注 |
|--------|----------|------|
| v1.0 | 2026-02-27 | 初版 |

---

## 〇、先看懂这张图

```mermaid
flowchart LR
    subgraph 正常操作
        A[用户点击] --> B{1分钟内<br/>操作次数}
        B -->|小于10次| C[执行操作]
        C --> D[记录日志]
    end
    subgraph 触发限流
        E[用户点击] --> F{1分钟内<br/>操作次数}
        F -->|已达10次| G[拒绝操作]
        G --> H[提示"操作太频繁"]
    end
```

**一句话**：限制用户在指定时间窗口内的操作次数，防止恶意刷接口或误操作。

---

## 一、这是什么

基于 Redis 计数器实现的用户级操作频率限制。当用户操作过于频繁时，自动拦截并拒绝执行。

| 场景 | 作用 |
|------|------|
| 防止恶意刷接口 | 限制单用户高频调用 |
| 防止误操作 | 用户手抖多次点击 |
| 保护下游系统 | 避免突发流量打垮依赖服务 |

**术语**：限流窗口 = 统计时间范围（如 1 分钟）；限流阈值 = 窗口内允许的最大操作次数。

---

## 二、典型场景

### 场景1：提交订单防连点

```
用户操作：点击"提交订单" → 点击 → 点击（手抖连点3次）
         ↓
结果：只有第1次真正执行，后2次被拦截提示"操作太频繁"
```

### 场景2：接口防刷

```
攻击者：用脚本每秒调用100次导出接口
       ↓
结果：只有前10次执行，后续请求被 Redis 计数器拦截
```

### 场景3：不同接口独立限流

```
配置：查询接口限流 100次/分钟，提交接口限流 5次/分钟
     ↓
结果：用户查询不触发限流，但频繁提交会被限制
```

---

## 三、怎么用

**开启方式**：在 `@OperationLog` 注解上添加限流配置

```java
@OperationLog(rateLimit = @RateLimit(window = 60, maxCount = 10))
@PostMapping("/submit")
public Result submit() {
    // 业务代码
}
```

**参数说明**：
- `window`：时间窗口（秒）
- `maxCount`：窗口内最大允许次数

**谁可以配置**：
- 开发人员：在代码中配置默认限流策略
- 运维人员：通过配置文件动态调整阈值

---

## 四、关键规则

### 规则1：限流维度

- 默认按 **用户ID + 接口方法** 维度限流
- 支持配置为 **用户ID** 维度（跨接口累计）
- 支持配置为 **接口方法** 维度（全用户共享配额）

**举例**：
```
用户A调用 /submit：计数器 +1
用户B调用 /submit：独立的计数器 +1
用户A调用 /query：另一个独立的计数器 +1
```

### 规则2：窗口滑动方式

- 默认使用 **固定窗口**（整点重置，如 10:00:00-10:00:59）
- 可选 **滑动窗口**（每次操作后重新计算时间范围）

### 规则3：触发限流后的行为

- 默认：抛出异常，返回"操作太频繁"
- 可选：静默跳过（不记录日志，不抛异常）

### 规则4：Redis Key 设计

```
operation-log:rate-limit:{userId}:{className}:{methodName}
```

带 TTL（过期时间 = window 秒），自动清理过期数据。

---

## 五、最终预期标准

- [ ] 配置了 `@RateLimit` 的接口，用户操作超过阈值时被拦截
- [ ] 限流计数存储在 Redis，重启应用后计数不丢失
- [ ] 不同用户、不同接口的计数相互隔离
- [ ] Redis 不可用时，降级为不限制（保证可用性）
- [ ] 限流触发时，操作日志不记录（因为没有真正执行）
