# 操作防重复提交 产品需求文档

**文档类型**：产品需求文档
**适用对象**：业务人员、产品、运营

| 版本号 | 更新时间 | 备注 |
|--------|----------|------|
| v1.0 | 2026-02-27 | 初版 |

---

## 〇、先看懂这张图

```mermaid
flowchart LR
    subgraph 第一次提交
        A[用户点击提交] --> B{Redis<br/>获取锁}
        B -->|获取成功| C[执行业务]
        C --> D[释放锁]
    end
    subgraph 重复点击
        E[用户再次点击] --> F{Redis<br/>获取锁}
        F -->|获取失败| G[提示"处理中"]
    end
```

**一句话**：利用 Redis 分布式锁防止用户重复提交，确保同一操作只执行一次。

---

## 一、这是什么

基于 Redis 分布式锁的幂等性保障机制。通过唯一请求标识识别重复请求，防止网络延迟或用户误操作导致的重复执行。

| 场景 | 作用 |
|------|------|
| 防止重复下单 | 用户点击多次只生成一个订单 |
| 防止重复支付 | 支付按钮防连点 |
| 防止重复导入 | 批量导入操作只执行一次 |

**术语**：幂等性 = 同一操作执行多次结果相同；Token = 唯一请求标识（由客户端生成或服务端分配）。

---

## 二、典型场景

### 场景1：提交订单防重

```
用户操作：点击"提交订单" → 网络卡顿 → 再次点击
         ↓
结果：只有第1个请求执行业务，第2个返回"处理中"
         ↓
最终：只生成1个订单
```

### 场景2：支付防重

```
用户操作：点击"立即支付" → 没反应 → 狂点5次
         ↓
结果：只有第1次调用支付接口
         ↓
最终：只扣款1次
```

### 场景3：批量导入防重

```
用户操作：选择文件 → 点击导入 → 误以为没反应 → 再次导入
         ↓
结果：第2次请求被拦截
         ↓
最终：数据只导入1次，无重复
```

---

## 三、怎么用

**开启方式**：在 `@OperationLog` 上启用幂等

```java
@OperationLog(idempotent = true, idempotentTimeout = 30)
@PostMapping("/submit")
public Result submit(@RequestBody OrderDTO dto) {
    // 业务代码
}
```

**客户端传递 Token**：

```http
POST /order/submit
Idempotent-Token: abc123xyz

{ ...请求体... }
```

**Token 生成方式**：
- 方式1：客户端生成 UUID（推荐表单提交）
- 方式2：服务端预分配 Token（通过 `/token` 接口获取）

**服务端预分配 Token**：

```java
@GetMapping("/idempotent-token")
public String getToken() {
    return operationLogService.generateToken();
}
```

---

## 四、关键规则

### 规则1：锁的粒度

- 默认按 **用户ID + Token** 维度加锁
- 支持配置为 **Token 唯一**（跨用户防重，如全局导入任务）
- 支持配置为 **用户ID + 接口 + 业务Key**（如订单号）

### 规则2：锁的超时时间

- 默认 30 秒（防止死锁）
- 可配置：短操作 10 秒，长任务 5 分钟
- 业务执行完立即释放，不等超时

### 规则3：重复请求的处理

- 默认：抛出异常，提示"操作处理中，请勿重复提交"
- 可选：返回上次执行结果（需缓存结果）

### 规则4：Redis Key 设计

```
# 分布式锁（String，带过期时间）
operation-log:idempotent-lock:{token}
value: 当前时间戳
expire: 30秒

# 结果缓存（可选，用于返回上次结果）
operation-log:idempotent-result:{token}
value: 上次执行结果JSON
expire: 5分钟
```

### 规则5：Token 复用策略

- 成功：Token 标记为已使用，结果缓存 5 分钟
- 失败：Token 释放，允许重新提交
- 处理中：重复请求被拒绝

---

## 五、最终预期标准

- [ ] 同一 Token 的重复请求被拦截
- [ ] 锁超时后自动释放，防止死锁
- [ ] 业务执行成功后可配置返回缓存结果
- [ ] Redis 不可用时降级为不防重（保证可用性）
- [ ] 防重逻辑对业务代码无侵入
- [ ] 锁等待时间 < 10ms
