# 模块-上下文与字段跟踪

## 0. 模块目标

以请求线程为单位保存本次日志采集所需的上下文，并提供“前后值采集（follow）/失败标记/标签/备注”等能力。

## 1. 边界

- **包含**：ThreadLocal 状态、`follow()` 采集 `preValue` 与 supplier、`addTags/addRemarks/markFail`、清理策略
- **不包含**：跨线程上下文传递、字段差异对比（当前只存 `preValue/afterValue`）

## 2. 可检索关键词

OperationLogContext / ThreadLocal / follow(Callable) / metadataSupplier / preValue / afterValue / addTags / addRemarks / markFail / clean / disable

## 3. 已实现能力（DONE）

- **全局开关**：存在 `OperationLogContext.disable`，为 `true` 时 `follow/addTags/addRemarks` 等直接返回（锚点：`OperationLogContext.disable` + 各方法开头判断）
- **请求级关联**：通过 `currentRecordId` 关联当前线程正在处理的 `LogRecord`（锚点：`OperationLogContext.currentRecordId` + `OperationLogContext.getCurrentLogRecord()`）
- **跟踪前值**：`follow(Callable<Object>)` 会把 `metadata.call()` 的结果序列化为 `JSONObject` 并写入 `LogRecord.preValue`（锚点：`OperationLogContext#follow`）
- **跟踪后值触发点**：`follow()` 仅保存 supplier；真正的 afterValue 读取发生在 `LogAspect#around` 的 finally（锚点：`OperationLogContext.metadataSupplier` + `LogAspect#around` 中 `setAfterValue` 逻辑）
- **失败标记**：提供 `markFail()` 将当前 `LogRecord.requestResult` 置为 `false`（锚点：`OperationLogContext#markFail`）
- **标签能力**：`addTags(String...)` 将非空 tag 写入 `LogRecord.tags`（LinkedHashSet 保持插入顺序）（锚点：`OperationLogContext#addTags` + `LogRecord.tags`）
- **备注能力**：`addRemarks(String...)` 将备注写入 `LogRecord.remarks`（锚点：`OperationLogContext#addRemarks` + `LogRecord.remarks`）
- **清理机制**：`clean()` 会 remove 当前 recordId 对应的 `recordId2Logs` 项，并清理全部 ThreadLocal（锚点：`OperationLogContext#clean`）

## 4. 主要入口与关键类

- `cn.creekmoon.operationLog.core.OperationLogContext`
- `cn.creekmoon.operationLog.core.LogAspect#initOperationLog`（写入 recordId 与 map）
- `cn.creekmoon.operationLog.core.LogAspect#around`（读取 supplier 并写 afterValue）

## 5. 核心流程（高层）

1. `LogAspect` 初始化 `LogRecord` 后设置 `currentRecordId` 并写入 `recordId2Logs`
2. 业务代码可在方法执行前调用 `OperationLogContext.follow(() -> ...)` 写入 `preValue` 并注册 supplier
3. 方法结束时 `LogAspect` 在 finally 中调用 supplier 得到 afterValue（若注册了）
4. `OperationLogContext.clean()` 清理上下文

## 6. 外部依赖

- Fastjson2（`JSONObject.parseObject/toJSONString`）
- Hutool（`StrUtil`）

## 7. 模块协作点

- `follow()` 必须发生在 `@OperationLog` 方法执行期间，否则 `getCurrentLogRecord()` 为 null（锚点：`OperationLogContext#follow` 的错误日志）
- `markFail()` 只改变 `requestResult`，最终是否记录仍由 `LogAspect#around` 的 `isNeedRecord` 判定决定（`handleOnFail` 参与）

## 8. 常见问题（优先看哪里）

- **README 示例里写 `OperationLogContext.fail()`**：代码中实际方法为 `OperationLogContext.markFail()`（锚点：`OperationLogContext#markFail` + `README.md` 示例）
- **为什么 follow 没产生 afterValue**：看是否启用 `@EnableOperationLog`（disable 是否被置为 false）以及 `LogAspect` finally 中的 `metadataSupplier` 读取逻辑

