# 模块-异步处理与扩展点

## 0. 模块目标

以异步方式把 `LogRecord` 分发给可插拔的扩展点：初始化器（填充用户信息等）与处理器（存储/输出日志）。

## 1. 边界

- **包含**：异步线程池、扩展点接口、默认实现、bean 装配约束（单初始化器/多处理器）
- **不包含**：任何具体存储实现（ES/DB/MQ 客户端由使用方实现）

## 2. 可检索关键词

LogThreadPool / ThreadPoolExecutor / CallerRunsPolicy / OperationLogHandler / OperationLogRecordInitializer / DefaultOperationLogHandler / DefaultOperationLogRecordInitializer / ConditionalOnMissingBean

## 3. 已实现能力（DONE）

- **异步线程池**：使用 `ThreadPoolExecutor`，核心线程 0，最大线程 4，队列 512，拒绝策略 `CallerRunsPolicy`（锚点：`cn.creekmoon.operationLog.core.LogThreadPool`）
- **统一提交入口**：通过 `LogThreadPool.runTask(Runnable)` 提交任务（锚点：`LogThreadPool#runTask`）
- **处理器扩展点**：`OperationLogHandler#handle(LogRecord)` 定义日志处理方式（锚点：`cn.creekmoon.operationLog.core.OperationLogHandler`）
- **初始化器扩展点**：`OperationLogRecordInitializer#init(LogRecord)` 用于初始化日志对象；并提供可选的后置钩子 `functionPostProcess`（锚点：`cn.creekmoon.operationLog.core.OperationLogRecordInitializer`）
- **多处理器调用**：切面会遍历 Spring 容器内所有 `OperationLogHandler` bean 并逐个调用，单个 handler 异常被捕获（锚点：`LogAspect#around` 异步任务内部 for 循环）
- **单初始化器约束（代码实现层面）**：切面通过 `applicationContext.getBean(OperationLogRecordInitializer.class)` 获取初始化器（锚点：`LogAspect#getLogDetailFactory`），因此使用方应保证仅有一个该类型 bean
- **默认处理器**：当缺少任何 `OperationLogHandler` bean 时，提供默认实现打印日志（锚点：`config/DefaultOperationLogHandler` 的 `@ConditionalOnMissingBean({OperationLogHandler.class})`）
- **默认初始化器**：当缺少任何 `OperationLogRecordInitializer` bean 时，提供默认实现写入 UNKNOWN 值（锚点：`config/DefaultOperationLogRecordInitializer`）

## 4. 主要入口与关键类

- `cn.creekmoon.operationLog.core.LogThreadPool`
- `cn.creekmoon.operationLog.core.OperationLogHandler`
- `cn.creekmoon.operationLog.core.OperationLogRecordInitializer`
- `cn.creekmoon.operationLog.config.DefaultOperationLogHandler`
- `cn.creekmoon.operationLog.config.DefaultOperationLogRecordInitializer`
- `cn.creekmoon.operationLog.core.LogAspect#around`（触发异步与分发）

## 5. 核心流程（高层）

1. `LogAspect` 创建 `LogRecord` 后调用 `OperationLogRecordInitializer#init`
2. 方法执行结束后，如果判定需要记录，则 `LogThreadPool.runTask` 提交异步任务
3. 异步任务遍历所有 `OperationLogHandler` bean 并调用 `handle(logRecord)`

## 6. 外部依赖

- Spring（bean 获取、`@ConditionalOnMissingBean`）
- JDK 并发（`ThreadPoolExecutor`）

## 7. 模块协作点

- **默认处理器替换规则**：只要容器中存在任意自定义 `OperationLogHandler`，默认处理器不会注册（`@ConditionalOnMissingBean(OperationLogHandler.class)`）
- **初始化器替换规则**：只要容器中存在任意自定义 `OperationLogRecordInitializer`，默认初始化器不会注册

## 8. 常见问题（优先看哪里）

- **为什么没看到控制台打印**：看是否已自定义 `OperationLogHandler`（默认处理器会被替换），以及 `LogAspect` 是否进入记录分支
- **为什么处理器没执行**：看 `LogAspect#around` 的 `isNeedRecord` 判定（成功或 `handleOnFail=true` 才会触发）

